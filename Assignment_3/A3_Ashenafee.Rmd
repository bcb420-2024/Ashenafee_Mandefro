---
title: "Assignment 3"
subtitle: "Non-thresholded GSEA and Network Visualization of CBD Treatment for SARS-CoV-2 Infection"
author: "Ashenafee Mandefro"
date: "04/01/2024"
bibliography: A3_Ashenafee.bib
output:
    html_document:
        toc: true
        number_sections: false
        code_folding: hide
csl: cse.csl
nocite: '@*'
---

<!-- R Setup -->
```{r install_dependencies, eval = TRUE, message = FALSE}
# Check if Biocondutor is installed
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

# Install knitr
if (!requireNamespace("knitr", quietly = TRUE))
    install.packages("knitr")

# Install edgeR
if (!requireNamespace("edgeR", quietly = TRUE))
    BiocManager::install("edgeR")

# Install gprofiler2
if (!requireNamespace("gprofiler2", quietly = TRUE))
    BiocManager::install("gprofiler2")

# Install RCy3
if (!requireNamespace("RCy3", quietly = TRUE))
    BiocManager::install("RCy3")
```

<!-- Setup Directories -->
```{r setup_directories, eval=TRUE, warning=FALSE, message=FALSE}
# Create the data directory if it doesn't exist
if (!dir.exists("data")) {
    dir.create("data")
}
data_dir <- paste0(getwd(), "/data")

# Create the downloads directory if it doesn't exist
if (!dir.exists("downloads")) {
    dir.create("downloads")
}
downloads_dir <- paste0(getwd(), "/downloads")

# Create the RData directory in the downloads directory if it doesn't exist
if (!dir.exists(file.path(downloads_dir, "RData"))) {
    dir.create(file.path(downloads_dir, "RData"))
}
rdata_dir <- file.path(downloads_dir, "RData")

# Create the output directory if it doesn't exist
if (!dir.exists("output")) {
    dir.create("output")
}
output_dir <- paste0(getwd(), "/output")

# Create the DE output directory if it doesn't exist
if (!dir.exists(file.path(output_dir, "de_results"))) {
    dir.create(file.path(output_dir, "de_results"))
}
de_output_dir <- file.path(output_dir, "de_results")

# Create the EM output directory if it doesn't exist
if (!dir.exists(file.path(output_dir, "em_results"))) {
    dir.create(file.path(output_dir, "em_results"))
}
em_output_dir <- file.path(output_dir, "em_results")
```

<!-- Loading Data -->
```{r load_data, eval=TRUE, warning=FALSE, message=FALSE}
# Download the .RData from GitHub
download.file(
    url = "https://github.com/bcb420-2024/Ashenafee_Mandefro/raw/main/Assignment%202/filtered_data_matrix.RData",
    destfile = paste0(rdata_dir, "/filtered_data_matrix.RData")
)
download.file(
    url = "https://github.com/bcb420-2024/Ashenafee_Mandefro/raw/main/Assignment%202/samples_type.RData",
    destfile = paste0(rdata_dir, "/samples_type.RData")
)
download.file(
    url = "https://github.com/bcb420-2024/Ashenafee_Mandefro/raw/main/Assignment%202/de_results.RData",
    destfile = paste0(rdata_dir, "/de_results.RData")
)

# Load the RData files
load(file.path(rdata_dir, "filtered_data_matrix.RData"))
load(file.path(rdata_dir, "samples_type.RData"))
load(file.path(rdata_dir, "de_results.RData"))

# Define the log2 TPM
lg2_tpm <- log2(filtered_data_matrix + 1)

# Save the expression data to a file
write.table(
    lg2_tpm,
    file = file.path(data_dir, "lg2_tpm.tsv"),
    sep = "\t",
    quote = FALSE
)
expression_data <- file.path(data_dir, "lg2_tpm.tsv")
```

<!-- Download the GSEA Executable -->
```{r download_gsea, eval=TRUE, warning=FALSE, message=FALSE, results="hide"}
download_and_unzip_gsea <- function() {
    # Define the URL for the GSEA archive
    gsea_url <- "https://github.com/bcb420-2024/Ashenafee_Mandefro/raw/main/Executables/GSEA_4.3.3.zip"

    # Download the GSEA archive to the downloads directory
    download.file(
        url = gsea_url,
        destfile = file.path(downloads_dir, "GSEA_4.3.3.zip")
    )

    # Unzip the GSEA archive
    unzip(
        zipfile = file.path(downloads_dir, "GSEA_4.3.3.zip"),
        exdir = downloads_dir
    )

    # Delete the GSEA archive
    file.remove(file.path(downloads_dir, "GSEA_4.3.3.zip"))
    
    # Define the path to the GSEA executable
    gsea_executable <- file.path(downloads_dir, "GSEA_4.3.3", "gsea-cli.sh")

    # Make the GSEA executable file executable (i.e., chmod +x)
    system(paste("chmod +x", shQuote(gsea_executable)))

    # Return the path to the GSEA executable
    return(gsea_executable)
}

# Check if GSEA folder already exists in the downloads directory
if (!dir.exists(file.path(downloads_dir, "GSEA_4.3.3"))) {
    # Call the function to download and unzip GSEA if necessary
    gsea_executable <- download_and_unzip_gsea()
} else {
    # Define the path to the GSEA executable
    gsea_executable <- file.path(downloads_dir, "GSEA_4.3.3", "gsea-cli.sh")
}
```

# Introduction

## Background {.tabset .tabset-fade}

### Phytocannabinoids

A phytocannabinoid is a cannabinoid that occurs naturally in plants, such as Cannabis *sativa*. The word "phyto" means "plant", and the prefix "phyto-" is used in biochemistry to refer to compounds derived from plants. These compounds are known to occur in several plant species besides cannabis. The distinction with the prefix "phyto-" must be made because the human body also produces cannabinoids, referred to as *endo*cannabinoids due to their endogenous nature.

### Cannabidiol (CBD)

Cannabidiol (CBD) is one of the numerous phytocannabinoids found in the Cannabis (Cannabis sativa) plant. However, it is not responsible for the "high" commonly associated with use of cannabis - that responsibility falls on delta-9 tetrohydrocannabinol (THC). CBD is a non-psychoactive compound, and has been shown to have a wide range of potential therapeutic properties, including anti-inflammatory, antioxidant, and neuroprotective effects [@atalayAntioxidativeAntiInflammatoryProperties2019; @cassanoCannabisSativaCannabidiol2020]. It has showed promise as a possible treatment for a variety of conditions, including epilepsy, anxiety, and chronic pain [@bonaccorsoCannabidiolCBDUse2019].

### SARS-CoV-2

A highly contagious virus, SARS-CoV-2 is the driving force behind the COVID-19 pandemic. It is a novel coronavirus that was first identified in December 2019 in Wuhan, China, and is primarily spread through respiratory droplets. Those who have been infected with the virus can experience a wide range of symptoms, from mild to severe, with the worst outcome being death. Due to its extreme impact on public health, global economy, and daily life, significant amounts of research went into treatment/prevention methods for the virus from 2020 to 2022.

## Primary Research

### Quick Summary of the Paper

[Cannabidiol Inhibits SARS-CoV-2 Replication through Induction of the Host ER Stress and Innate Immune Responses](https://www.science.org/doi/10.1126/sciadv.abi6110) discusses the effects of CBD treatment in SARS-CoV-2 infected cells and mice, through its action of preventing replication of the virus. The researchers found that these effects are apparent in lung epithelial cells which is a critical finding, given that SARS-CoV-2 manifests itself with many respiratory issues[@nguyenCannabidiolInhibitsSARSCoV22022].

### Data Overview

The RNASeq data from this paper is available on the [Gene Expression Omnibus (GEO)](https://www.ncbi.nlm.nih.gov/geo/) under the accession number [GSE168797](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE168797). More information about the data is summarized in the table below:

| Attribute    | Value |
|--------|-------|
| Title  | Cannabidiol Inhibits SARS-CoV-2 Replication through Induction of the Host ER Stress and Innate Immune Responses   |
| Organism | Homo sapiens |
| Paper  | Nguyen, L. C., Yang, D., Nicolaescu, V., Best, T. J., Gula, H., Saxena, D., Gabbard, J. D., Chen, S. N., Ohtsuki, T., Friesen, J. B., Drayman, N., Mohamed, A., Dann, C., Silva, D., Robinson-Mailman, L., Valdespino, A., Stock, L., Suárez, E., Jones, K. A., Azizi, S. A., … Rosner, M. R. (2022). Cannabidiol inhibits SARS-CoV-2 replication through induction of the host ER stress and innate immune responses. Science advances, 8(8), eabi6110. https://doi.org/10.1126/sciadv.abi6110   |
| Samples | 24 |
| Status | Public on Jan 20, 2022   |

<!-- Include a brief introduction section with a summary of the normalization and scoring done in the first two assignments. Assume that the person reading the report has not read your assignment #1 or #2 report. Including basic statistics from that analysis will be helpful. (for example, data downloaded from GEO with id X, …) -->

# Data Preparation {.tabset .tabset-fade}

The initial dataset from GEO had 57 832 genes, but after cleaning the dataset, we were left with 20 438 entries for subsequent analyses. The results of processing and normalization were visualized using a boxplot and a density plot to see the distribution of the data. These plots were constructed using the `ggplot2` R package.

## Boxplot

```{r boxplot, fig.cap="Boxplot of the normalized data", fig.align="center", out.width="100%"}
# Define the log2 TPM
lg2_tpm <- log2(filtered_data_matrix + 1)

# Set the boxplot colors
box_colors <- c(rep("red", 6), rep("blue", 6))

# Plot the normalized data
boxplot(
    lg2_tpm,
    xaxt = "n",
    las = 2,
    main = "Cannabidiol as COVID Treatment RNASeq Boxplot (Normalized)",
    ylab = "Log2 TPM",
    xlab = "Treatment",
    cex = 0.5,
    cex.lab = 0.8,
    col = box_colors
)

# Draw the median line
abline(
    h = median(apply(lg2_tpm, 2, median)),
    col = "green",
    lty = 2,
    lwd = 2
)

# Add x-axis labels manually with a 45 degree rotation
text(
    x = seq_along(lg2_tpm),
    y = par("usr")[3] - 0.2,
    adj = 1,
    srt = 45,
    labels = colnames(lg2_tpm),
    xpd = TRUE,
    cex = 0.8
)

# Add a legend (red - SAR-CoV-2, blue - Mock)
legend(
    "topright",
    legend = c("SARS-CoV-2", "Mock"),
    fill = c("red", "blue")
)
```

## Density Plot

```{r densityplot, fig.cap="Density plot of the normalized data", fig.align="center", out.width="100%"}
# Density plot
counts_density <- apply(lg2_tpm, 2, density)
xlim <- 0
ylim <- 0
for (i in seq_along(counts_density)) {
    xlim <- range(c(xlim, counts_density[[i]]$x))
    ylim <- range(c(ylim, counts_density[[i]]$y))
}

cols <- rainbow(length(counts_density))
ltys <- rep(1, length(counts_density))
plot(
    counts_density[[1]],
    xlim = xlim,
    ylim = ylim,
    type = "n",
    ylab = "Smoothing density of log2-CPM",
    main = "",
    cex.lab = 0.85
)
for (i in seq_along(counts_density)) {
    lines(counts_density[[i]], col = cols[i], lty = ltys[i])
}

legend(
    "topright",
    legend = colnames(lg2_tpm),
    col = cols,
    lty = ltys,
    cex = 0.8
)
```

# Differential Expression Analysis

We examined the differential expression between CBD-treated and DMSO-treated healthy A549 cells. The analysis was performed using the `edgeR` package in R. The results were visualized using a volcano plot (below) with highlights on three genes mentioned in the original publication: ATF6, EIF2AK3, and ERN1.

```{r volcano_plot, fig.cap="Volcano plot of the differential expression analysis", out.width="100%", echo=FALSE, warning=FALSE, error=FALSE}
# Fetch the volcano plot from GitHub if it doesn't exist
if (!file.exists(file.path(de_output_dir, "volcano_plot.svg"))) {
    download.file(
        url = "https://github.com/bcb420-2024/Ashenafee_Mandefro/blob/main/Assignment%202/volcano_plot.svg",
        destfile = file.path(de_output_dir, "volcano_plot.svg")
    )
}

# Display the volcano plot
knitr::include_graphics(c(paste0("./output/", "de_results/volcano_plot.svg")))
```

# Thresholded Enrichment Analysis (Over-representation Analysis) {.tabset .tabset-fade}

To examine the biological processes that either have increased or decreased activity from the treatment, we performed an over-representation analysis (ORA) using the `gprofiler2` R package. This method of analysis used a list of the significantly up- and down-regulated genes from the previous DE analysis which passed the the adjusted p-value threshold of 0.05. The results of this analysis gave us insight into which pathways were most affected through the CBD treatment.

The ORA was ran three times with differing input lists to compare and contrast the results of providing `gprofiler2` with up-regulated genes, down-regulated genes, and both up and downregulated genes.

## Upregulated Genes

```{r upregulated_genes, eval=TRUE, warning=FALSE, message=FALSE}
```

## Downregulated Genes

```{r downregulated_genes, eval=TRUE, warning=FALSE, message=FALSE}
```

## Both Up and Downregulated Genes

```{r both_up_downregulated_genes, eval=TRUE, warning=FALSE, message=FALSE}
```

# Non-thresholded Enrichment Analysis (Gene Set Enrichment Analysis)

Given that we have <!-- TODO: Number of non-significantly expressed genes --> genes that were neither significantly upregulated or downregulated, we can perform a gene set enrichment analysis (GSEA) to identify the pathways that may be further affected by this group of genes.

Since GSEA operates under the assumption of microarray data, we must apply some transformations to our data to specify the rank of each gene. The equation for this transformation is below:
$$\text{Rank} = -\log_{10}(p) \times \text{sign}(LFC)$$
Where:

- $p$ is the p-value of the gene

- $LFC$ is the log fold change of the gene

```{r rank_genes, eval=TRUE, warning=FALSE, message=FALSE}
# Create a data frame to store the ranks
rank_df <- data.frame(
    GeneName = rownames(de_results),
    Rank = -log10(de_results$PValue) * sign(de_results$logFC)
)

# Save the ranks to a file
rank_file <- file.path(data_dir, "CBD-Healthy_vs_CBD-Infect_rank.rnk")
write.table(rank_df, rank_file, sep = "\t", row.names = FALSE, quote = FALSE)
```

## Loading the Gene Sets from the Bader Lab

GSEA comes with its own set of gene sets for the analysis, but they're not frequently updated (i.e., the sets are updated on a near-yearly basis) meaning that some information could be lost if its tied to a newer annotation. The `.gmt` from the Bader Lab contains more pathways and is updated on a monthly basis allowing for more information to be pulled.

For our purposes, we will be using the gene set that *does not* include inferred electronic annotations (IEAs).

```{r load_gene_sets, eval=TRUE, warning=FALSE, message=FALSE}
download_gmt_file <- function(species) {
    # Base URL for the Bader Lab downloads website
    bader_url <- "https://download.baderlab.org/"

    # URL that points to the latest release for the specified species
    gmt_url <- paste0(
        bader_url,
        "EM_Genesets/current_release/",
        species,
        "/symbol/"
    )

    # Fetch a list of files available at the endpoint
    filenames <- RCurl::getURL(gmt_url)
    tc <- textConnection(filenames)
    contents <- readLines(tc)
    close(tc)

    # Construct the regex pattern to match the .gmt files. It should match:
    #   - Gene sets with Biological Pathways (BP)
    #   - Contain all pathways
    #   - Does NOT contain IEAs from GO
    #   - Does NOT contain PFOCR
    rx <- gregexpr(
        "(?<=<a href=\")(.*.GOBP_AllPathways_noPFOCR_no_GO_iea.*.)(.gmt)(?=\">)",
        contents,
        perl = TRUE
    )
    gmt_file <- unlist(regmatches(contents, rx))

    # Build the destination location of the file
    dest_gmt_file <- file.path(data_dir, gmt_file)

    # Download the file
    download.file(
        url = paste0(gmt_url, gmt_file),
        destfile = dest_gmt_file
    )

    # Return the name of the downloaded file
    return(gmt_file)
}

# List the files in the data/ directory
data_files <- list.files(data_dir)

# Check if any of the files are a gene set file
if (!any(grepl(".gmt", data_files))) {
    # Download the gene set file
    gmt_file <- download_gmt_file("Human")
} else {
    # Print a message indicating that the file already exists
    message("Gene set file already exists.")
    # Get the name of the gene set file
    gmt_file <- data_files[grepl(".gmt", data_files)]
}
```
We will proceed with using `r gmt_file` as our gene set file.

## Performing the GSEA

We have downloaded the GSEA executable to `downloads/GSEA_X.X.X` (where `X.X.X` is the version number) and made reference to the entrypoint for the program in `gsea_executable`. Before we perform the GSEA, we must store reference to the relevant directories and files the analysis will be using.

```{r setup_gsea, eval=TRUE, warning=FALSE, message=FALSE}
# Create a directory for the GSEA results within the output directory
gsea_output_dir <- file.path(output_dir, "gsea_results")
if (!dir.exists(gsea_output_dir)) {
    dir.create(gsea_output_dir)
}

# Name the GSEA analysis
gsea_analysis_name <- "CBD_vs_DMSO"

# Define the input rank file
rank_file <- file.path(data_dir, paste0(gsea_analysis_name, "_rank.rnk"))

# Define the GSEA command
command <- sprintf(
    "%s GSEAPreRanked -gmx %s -rnk %s -collapse false -nperm 1000 -scoring_scheme weighted -rpt_label %s -plot_top_x 20 -rnd_seed 12345 -set_max 200 -set_min 15 -zip_report false -out %s > gsea_output.txt",
    shQuote(gsea_executable),
    shQuote(file.path(data_dir, gmt_file)),
    shQuote(rank_file),
    shQuote(gsea_analysis_name),
    shQuote(gsea_output_dir)
)
```

With everything set up, we can now perform our GSEA.

```{r run_gsea, eval=TRUE, warning=FALSE, message=FALSE}
# Check if results already exist
gsea_result_folder <- list.files(gsea_output_dir)
if (length(gsea_result_folder) == 0) {
    # Run the GSEA command
    system(command)
} else {
    message("GSEA results already exist.")
}

# Get a list of the TSV files in the GSEA results directory
gsea_files <- list.files(paste(gsea_output_dir, gsea_result_folder, sep = "/"))
gsea_files <- gsea_files[grep(".tsv", gsea_files)]
```

## GSEA Results

```{r gsea_results, eval=TRUE, warning=FALSE, message=FALSE}
# Find the overall reports of the GSEA
rx <- gregexpr("gsea_report_for_.*\\.tsv", gsea_files)
gsea_report_files <- gsea_files[unlist(rx) > 0]
na_pos_file <- gsea_report_files[grep("na_pos", gsea_report_files)]
na_neg_file <- gsea_report_files[grep("na_neg", gsea_report_files)]

# Load the GSEA results (.tsv) into a data frame
na_pos_report <- read.delim(
    file.path(gsea_output_dir, gsea_result_folder, na_pos_file),
    sep = "\t"
)
na_neg_report <- read.delim(
    file.path(gsea_output_dir, gsea_result_folder, na_neg_file),
    sep = "\t"
)

# Number of upregulated gene sets for both conditions
num_upreg_pos <- nrow(na_pos_report)
num_upreg_neg <- nrow(na_neg_report)
total_genesets <- num_upreg_pos + num_upreg_neg

# Number of gene sets with FDR < 25%
num_upreg_pos_fdr <- sum(na_pos_report$FDR < 0.25)
num_upreg_neg_fdr <- sum(na_neg_report$FDR < 0.25)

# Number of gene sets with pvalue < 1%
num_upreg_pos_pval <- sum(na_pos_report$NOM.p.val < 0.01)
num_upreg_neg_pval <- sum(na_neg_report$NOM.p.val < 0.01)

# Number of gene sets with pvalue < 5%
num_upreg_pos_pval_5 <- sum(na_pos_report$NOM.p.val < 0.05)
num_upreg_neg_pval_5 <- sum(na_neg_report$NOM.p.val < 0.05)
```

## Insights

**1. What method was used to perform the GSEA?**

The GSEA was performed using version 4.3.3 of [GSEA for the command line](). This enrichment analysis was performed on the results of the differential expression analysis between CBD-treated and DMSO-treated healthy A549 cells. This data was transformed to create a rank file based on each gene's p-value and log fold change. The initial, raw RNASeq data was download from GEO with the accession number [GSE168797](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE168797).

**2. What gene sets did you use for your enrichment analysis?**

The gene set used for the enrichment analysis was obtained from the Bader Lab's [curated collection](https://download.baderlab.org/). The gene set file used was ``r gmt_file``. The `.gmt` was the latest release (March 01, 2024 at the time of writing) and contained gene sets for biological pathways that *did not* include inferred electronic annotations (IEAs).

**3. Provide a summary of your enrichment results.**

```{r gsea_summary, eval=TRUE, warning=FALSE, message=FALSE}
# Create a data frame to store the summary
gsea_summary <- data.frame(
    Condition = c("CBD_Infect", "CBD_Healthy"),
    NumGeneSets = c(num_upreg_pos, num_upreg_neg),
    NumGeneSetsFDR = c(num_upreg_pos_fdr, num_upreg_neg_fdr),
    NumGeneSetsPVal = c(num_upreg_pos_pval, num_upreg_neg_pval),
    NumGeneSetsPVal5 = c(num_upreg_pos_pval_5, num_upreg_neg_pval_5)
)

# Update the column names
colnames(gsea_summary) <- c("Condition", "Total Gene Sets", "Gene Sets (FDR < 25%)", "Gene Sets (p-value < 1%)", "Gene Sets (p-value < 5%)")

# Display the summary
knitr::kable(
    gsea_summary,
    caption = "Summary of the GSEA results for the CBD treatment of SARS-CoV-2 infection."
)
```

**4. Compare the results of this non-thresholded analysis to the thresholded analysis performed in Assignment 2.**

<!-- Display ORA and GSEA top5 results here and discuss if the pathways are the same. If not, discuss if the general themes are the same. -->

<!-- TODO -->

**5. Is comparing a non-thresholded vs. a thresholded analysis straightforward? Why or why not?**

It's not a straightforward comparison because in a GSEA analysis, all of the genes in the initial DE results are factored. On the other hand, the ORA only accounts for the significantly upregulated/downregulated genes. This means we lose out on a lot of information in the pathways that are shown as the output.

For example, a non-significantly expressed gene could be part of a pathway that is significantly affected by the treatment.

Overall, ORA results only factor in genes that are expressed beyond a threshold, whereas GSEA factors in everything in the dataset. This makes it difficult to compare the two analyses directly.

<!-- TODO -->

# Visualization using Cytoscape


## Enrichment Map Setup

Prior to creating our enrichment map (EM), we will setup the thresholds for our analysis. The thresholds will allow us to filter out gene sets that aren't as significant as we need for analysis. We are using the following thresholds:

```{r em_threshold_setup, eval=TRUE, warning=FALSE, message=FALSE}
# Define the p-value threshold
pvalue_gsea_threshold <- 1.0

# Define the q-value threshold
qvalue_gsea_threshold <- 0.05

# Define the similarity threshold
similarity_threshold <- "0.375"

# Output the thresholds
knitr::kable(
    data.frame(
        PValue = pvalue_gsea_threshold,
        QValue = qvalue_gsea_threshold,
        Similarity = similarity_threshold
    ),
    caption = "Thresholds used for the Enrichment Map analysis."
)

#defined threshold for GSEA enrichments 
#p-value to filter all the genesets.  For example -   1.0
pvalue_gsea_threshold <- 1.0

#q-value to filter all the genesets.  For example -   0.05
qvalue_gsea_threshold <- 0.05

#similarity threshold to filter all the genesets connections/edges.  
# For example -   0.375
similarity_threshold <- "0.375"

#similarity metric to filter all the genesets connections/edges 
# (can be OVERLAP, JACCARD, or COMBINED.   For example -   Combined
similarity_metric = "COMBINED"
```
The **p-value** threshold will ensure that only gene sets with a p-value of at most 1.0 will be included in the analysis. In a similar fashion, the **q-value** threshold is used to limit the gene sets in our analysis to those with $q-value < 0.05$.

```{r em_metric_definition, eval=TRUE, warning=FALSE, message=FALSE}
# Define the similarity metric
similarity_metric <- "COMBINED"
```
**TODO: Figure out similarity**

The **similarity** threshold is used to filter out gene sets that are not similar enough to be connected in the enrichment map. The similarity metric used is **Combined**.

```{r em_input_data_setup, eval=TRUE, warning=FALSE, message=FALSE}
# Specify the location of the required files:
#   - .gmt file
#   - enrichment results
gmt_file <- file.path(data_dir, gmt_file)
enrichment_results <- file.path(
    gsea_output_dir, gsea_result_folder, "edb", "results.edb"
)

# Specify the location of the required files:
#   - expression data
#   - ranks file
em_expression_data <- shQuote(expression_data)
ranks_file <- shQuote(rank_file)

# Define the name of the analysis
em_analysis_name <- "CBD_vs_DMSO"
```

With the thresholds and input data set, we can now proceed with creating our EM.

## Using Cytoscape

Our network analysis will be ran using Cytoscape and apps that are available through it. As a result, we must first ensure Cytoscape is running and that we can connect to it through its REST API (CyREST) before any analysis can be performed.

```{r connect_to_cytoscape, eval=TRUE, warning=FALSE, message=TRUE}
# Function to ping Cytoscape using the provided cyrest_url
#
# Args:
#   cyrest_url: The base URL of the Cytoscape REST API
#
# Returns:
#   A logical value indicating whether the ping was successful or not
ping_cytoscape <- function(cyrest_url) {
    oldw <- getOption("warn")
    options(warn = -1)
    result <- tryCatch({
        RCy3::cytoscapePing(base.url = cyrest_url)
        TRUE
    }, error = function(e) {
        FALSE
    })
    options(warn = oldw)
    return(result)
}

# Define the URL for accessing CyREST from Docker
base_url <- "http://host.docker.internal:1234"
cyrest_url <- paste0(base_url, "/v1")

# Stop the analysis if Cytoscape is not running
if (!ping_cytoscape(cyrest_url)) {
    stop("Cytoscape is not running. Please start Cytoscape and try again.")
} else {
    # Output the apiVersion and cytoscapeVersionInfo
    cat(sprintf(
        "\tCytoscape API Version: %s\n\tCytoscape Version Info: %s\n",
        RCy3::cytoscapeVersionInfo(base.url = cyrest_url)["apiVersion"],
        RCy3::cytoscapeVersionInfo(base.url = cyrest_url)["cytoscapeVersion"]
    ))
}
```

The EM is created through the `enrichmentmap` app available through the Cytoscape App Store. Since it runs through Cytoscape, we must first ensure that Cytoscape is running and that we can connect to it through the REST API (CyREST). Overall, our Cytoscape setup will involve the following steps:

1. Ensure `EnrichmentMap`, `AutoAnnotate`, and any other necessary apps are installed in Cytoscape.
2. Upload the required files to Cytoscape.
3. Create the enrichment map.
4. Export an image of the enrichment map.

### Installing Cytoscape Apps

We use the `installApp` function provided by `RCy3` to install `EnrichmentMap` and `AutoAnnotate`.
```{r install_cytoscape_apps, eval=TRUE, warning=FALSE, message=TRUE}
# Wrapper function to install Cytoscape apps using RCy3
#
# Args:
#   cyrest_url: The base URL of the Cytoscape REST API
#   apps: A list of apps to install
#
# Returns:
#   A list of the newly installed apps
install_cytoscape_apps <- function(cyrest_url, apps) {

    # Load a list of the currently installed apps
    installed_apps <- RCy3::getInstalledApps(base.url = cyrest_url)
    new_apps <- c()

    for (app in apps) {
        # Check if the app is already installed
        if (!any(grepl(tolower(app), tolower(installed_apps)))) {
            RCy3::installApp(app, base.url = cyrest_url)
            new_apps <- c(new_apps, app)
        } else {
            message(sprintf("App '%s' is already installed.", app))
        }
    }

    return(new_apps)
}

# Install the required Cytoscape apps
apps <- c("enrichmentmap", "autoannotate")
installed_apps <- RCy3::getInstalledApps(base.url = cyrest_url)
new_apps <- install_cytoscape_apps(cyrest_url, apps)
knitr::kable(
    data.frame(
        App = new_apps
    ),
    caption = "Newly installed Cytoscape apps."
)
```

### Uploading Data to Cytoscape

To perform our analysis, we need to provide the following files to Cytoscape:

- The gene set file in `.gmt` format.
- The enrichment results file.
- The expression data file.
- The ranks file.

Since Cytoscape is running on the host operating system, we have to provide it with the input files that were generated in the Docker container. We will use the CyREST API to upload these files to Cytoscape.
```{r upload_data_to_cytoscape, eval=TRUE, warning=FALSE, message=FALSE}
# Function to upload data to Cytoscape using the provided cyrest_url
#
# Args:
#   cyrest_url: The base URL of the Cytoscape REST API
#   files: A list of files to upload
#
# Returns:
#   A logical value indicating whether the upload was successful or not
upload_data_to_cytoscape <- function(cyrest_url, files) {
    # Store the uploaded file paths
    uploaded_paths <- c()

    for (file in files) {
        # Build the POST request
        bname <- basename(file)
        r <- httr::POST(
            url = paste0(
                cyrest_url, "/enrichmentmap/textfileupload?fileName=", bname
            ),
            config = list(),
            body = list(file = httr::upload_file(file)),
            encode = "multipart",
            handle = NULL
        )

        # Check if the upload was successful
        uploaded_paths <- c(uploaded_paths, httr::content(r, "parsed")$path)
    }

    return(uploaded_paths)
}

# Upload the required files to Cytoscape
em_files <- c(gmt_file, enrichment_results, expression_data, rank_file)
uploaded_files <- upload_data_to_cytoscape(base_url, em_files)

# Store the host file paths
gmt_file_host <- uploaded_files[1]
enrichment_results_host <- uploaded_files[2]
expression_data_host <- uploaded_files[3]
rank_file_host <- uploaded_files[4]
```

## Create the Enrichment Map

With the Cytoscape Apps installed and the data imported, we can now move on to creating our EMs. We will create two EMs: one with a q-value threshold of 0.05 and another with a q-value threshold of 0.01. Both EMs will use a p-value threshold of 1.0.
```{r create_enrichment_map, eval=TRUE, warning=FALSE, message=FALSE}
# Function to create an enrichment map using the provided cyrest_url
#
# Args:
#   cur_model_name: The name of the current model
#   pvalue_gsea_threshold: The p-value threshold for the GSEA analysis
#   qvalue_gsea_threshold: The q-value threshold for the GSEA analysis
#   similarity_threshold: The similarity threshold for the enrichment map
#   similarity_metric: The similarity metric for the enrichment map
#   gsea_ranks_file: The file containing the GSEA ranks
#   gsea_results_filename: The file containing the GSEA results
#   expression_file_fullpath: The full path to the expression data file
#   gmt_gsea_file: The file containing the GSEA gene sets
#   current_base: The base URL of the Cytoscape REST API
#
# Returns:
#   The response from the Cytoscape REST API
create_enrichment_map <- function(
    cur_model_name, pvalue_gsea_threshold, qvalue_gsea_threshold,
    similarity_threshold, similarity_metric, gsea_ranks_file,
    gsea_results_filename, expression_file_fullpath, gmt_gsea_file,
    current_base
) {
    # Construct the network name
    current_network_name <- paste(
        cur_model_name,
        pvalue_gsea_threshold,
        qvalue_gsea_threshold,
        sep = "_"
    )

    # Construct the EM command
    em_command <- paste(
        'enrichmentmap build analysisType="gsea"',
        "gmtFile=", gmt_gsea_file,
        "pvalue=", pvalue_gsea_threshold,
        "qvalue=", qvalue_gsea_threshold,
        "similaritycutoff=", similarity_threshold,
        "coefficients=", similarity_metric,
        "ranksDataset1=", gsea_ranks_file,
        "enrichmentsDataset1=", gsea_results_filename,
        "filterByExpressions=false",
        "expressionDataset1=", expression_file_fullpath,
        "gmtFile=", gmt_gsea_file,
        sep = " "
    )

    # Execute the EM command
    response <- RCy3::commandsGET(em_command, base.url = current_base)

    # Initialize network SUID
    current_network_suid <- 0

    # Check if the command execution failed
    if (grepl(pattern = "Failed", response)) {
        return(paste(response))
    } else {
        current_network_suid <- response
    }

    # Check if the network name is unique
    current_names <- RCy3::getNetworkList(base.url = current_base)

    # If the name already exists, prepend the SUID to the name
    if (current_network_name %in% current_names) {
        current_network_name <- paste(
            current_network_suid,
            current_network_name,
            sep = "_"
        )
    }

    # Rename the network
    response <- RCy3::renameNetwork(
        title = current_network_name,
        network = as.numeric(current_network_suid),
        base.url = current_base
    )

    return(response)
}

# 1. Initial EM (p = 1.0, q = 0.05)
em_response <- create_enrichment_map(
    em_analysis_name, pvalue_gsea_threshold, qvalue_gsea_threshold,
    similarity_threshold, similarity_metric, rank_file_host,
    enrichment_results_host, expression_data_host, gmt_file_host,
    cyrest_url
)
em_response_suid <- em_response$network

# 2. More Stringent EM (p = 1.0, q = 0.05)
em_analysis_name_stringent <- paste0(em_analysis_name, "_stringent")
em_response_stringent <- create_enrichment_map(
    em_analysis_name_stringent, pvalue_gsea_threshold, 0.01,
    similarity_threshold, similarity_metric, rank_file_host,
    enrichment_results_host, expression_data_host, gmt_file_host,
    cyrest_url
)
em_response_stringent_suid <- em_response_stringent$network
```


```{r export_enrichment_map, eval=TRUE, warning=FALSE, message=FALSE, fig.align="center"}
# Function to export the enrichment map as an image
#
# Args:
#   current_base: The base URL of the Cytoscape REST API
#   current_network_name: The name of the current network
#   output_dir: The directory to save the image
#
# Returns:
#   The response from the Cytoscape REST API
export_enrichment_map <- function(
    current_base, current_network_name, output_dir
) {
    # Fit the content
    RCy3::fitContent(base.url = current_base)

    # Create the full destination
    output_file <- paste0(
        output_dir, "/", current_network_name, ".png"
    )

    # Check to see if the file already exists
    if (file.exists(output_file)) {
        # Remove the file
        file.remove(output_file)
    }

    # Export the image
    response <- RCy3::exportImage(
        output_file,
        type = "png",
        base.url = current_base
    )

    return(response)
}

# The export_enrichment_map function does not work because of the separation
# between the host filesystem and Docker's filesystem. As a result, the image
# for the EM will be fetched from the output/em_results folder since it cannot
# be generated through this RMarkdown document.
# export_enrichment_map(
#     cyrest_url,
#     paste0(em_analysis_name, "_initial_network.png"),
#     em_output_dir
# )

# Fetch the images from the output/em_results folder
em_image <- file.path(
    em_output_dir,
    paste0(em_analysis_name, "_initial_network.svg")
)
em_image_stringent <- file.path(
    em_output_dir,
    paste0(em_analysis_name, "_stringent_network.svg")
)

# Check if the image exists
if (!file.exists(em_image_stringent)) {
    stop("The stringent EM image does not exist. Please check the output/em_results directory.")
}

# Display the stringent image
knitr::include_graphics(
    paste0(
        "./output/", "em_results/", em_analysis_name, "_stringent_network.svg"
    )
)
```

## Initial Analysis

After creating both our enrichment maps, we can now examine some basic statistics of the size of each to see how thresholds affect the network.
```{r get_size_of_network, eval=TRUE, warning=FALSE, message=FALSE}
# Get the number of nodes and edges in the initial network
num_nodes_initial <- RCy3::getNodeCount(
    network = em_response_suid,
    base.url = cyrest_url
)
num_edges_initial <- RCy3::getEdgeCount(
    network = em_response_suid,
    base.url = cyrest_url
)

# Get the number of nodes and edges in the stringent network
num_nodes_stringent <- RCy3::getNodeCount(
    network = em_response_stringent_suid,
    base.url = cyrest_url
)
num_edges_stringent <- RCy3::getEdgeCount(
    network = em_response_stringent_suid,
    base.url = cyrest_url
)

# Output the results
knitr::kable(
    data.frame(
        Network = c("Initial", "Stringent"),
        Nodes = c(num_nodes_initial, num_nodes_stringent),
        Edges = c(num_edges_initial, num_edges_stringent)
    ),
    caption = "Size of the Enrichment Maps."
)
```

Notice that after setting a more stringent threshold, we see that relatively few terms remain, along with their regulation status. It is interesting that there is a great number of downregulated terms, possibly indicating that CBD treatment has a greater effect in downregulation.

## Annotating the Enrichment Map

To add more information to the visual, we will annotate the map using the `AutoAnnotate` app available in Cytoscape [@Kucera2016]. Specifically, the annotation will use the `annotate-clusterBoosted` method. As a baseline annotation effort, we first summarized the stringent network and then ran `autoannotate` on it, giving the following figure.

```{r annotate_enrichment_map, eval=TRUE, warning=FALSE, message=FALSE, fig.align="center"}
# Function to annotate the current enrichment map using the provided cyrest_url
#
# Args:
#   current_base: The base URL of the Cytoscape REST API
#
# Returns:
#   The response from the Cytoscape REST API
annotate_enrichment_map <- function(current_base) {
    # Annotate the network
    response <- RCy3::commandsGET(
        paste(
            "autoannotate annotate-clusterBoosted",
            "network=current",
            sep = " "
        ),
        base.url = current_base
    )

    return(response)
}

# Function to summarize the current enrichment map using the provided cyrest_url
#
# Args:
#   current_base: The base URL of the Cytoscape REST API
#
# Returns:
#   The response from the Cytoscape REST API
summarize_enrichment_map <- function(current_base) {
    # Annotate the network
    response <- RCy3::commandsGET(
        paste(
            "autoannotate summary",
            "network=current",
            sep = " "
        ),
        base.url = current_base
    )

    return(response)
}

# Annotate and summarize the network
annotated_network <- annotate_enrichment_map(cyrest_url)
annotated_network <- summarize_enrichment_map(cyrest_url)

# Load the image and display it
em_image <- file.path(
    em_output_dir,
    paste0(em_analysis_name, "_baseline_annotated_network.svg")
)
knitr::include_graphics(em_image)
```

Before continuing further analysis we will remove the nodes that are not connected to any other nodes in the network. This will help us focus on the most relevant pathways in the network that have several of their components modified through treatment. To accomplish this, we will use the `filter` command in Cytoscape, and set this filter to only select the nodes that are within a distance of 3 of a node with a degree of 3 or more.

```{r filter_the_em, eval=TRUE, warning=FALSE, message=FALSE}
# Create a filter to limit the number of nodes.
#
# Args:
#   current_base: The base URL of the Cytoscape REST API
#   filter_json: The JSON specifying the filter
#   filter_name: The name of the filter
#   apply: A logical value indicating whether to apply the filter
#
# Returns:
#   The name of the filter
create_filter <- function(
    current_base, filter_json, filter_name, apply = TRUE
) {

    # Create the request body
    req_body <- jsonlite::toJSON(
        list(
            json = jsonlite::toJSON(filter_json, auto_unbox = TRUE),
            name = filter_name,
            apply = apply
        ),
        auto_unbox = TRUE
    )

    # Create the filter
    r <- httr::POST(
        url = paste0(
            current_base,
            "/commands",
            "/filter",
            "/create"
        ),
        body = jsonlite::fromJSON(req_body),
        encode = "json",
        handle = NULL
    )

    # Check the status of the response
    if (r$status != 200) {
        stop(sprintf("Failed to create filter: Code %s", r$status))
    }

    return(filter_name)
}

# Grab the SUIDs of the selected nodes
#
# Args:
#   current_base: The base URL of the Cytoscape REST API
#
# Returns:
#   The SUIDs of the selected nodes
get_node_suids <- function(current_base) {

    # Create the request body
    req_body <- jsonlite::toJSON(
        list(
            nodeList = "selected"
        ),
        auto_unbox = TRUE
    )

    # Create the filter
    r <- httr::POST(
        url = paste0(
            current_base,
            "/commands",
            "/node",
            "/list"
        ),
        body = jsonlite::fromJSON(req_body),
        encode = "json",
        handle = NULL
    )


    # Check the status of the response
    if (r$status != 200) {
        stop(sprintf("Failed to create filter: Code %s", r$status))
    }

    # Parse the response
    selected_nodes <- jsonlite::fromJSON(httr::content(r, "text"))

    return(selected_nodes)
}

# Grab the specified properties of the nodes
#
# Args:
#   current_base: The base URL of the Cytoscape REST API
#   properties: The properties to get
#   selected: Whether to query selected nodes or not
#
# Returns:
#   The properties of the selected nodes
get_node_properties <- function(current_base, properties, selected) {

    # Concatenate the properties vector into one string for query
    properties_str <- paste(properties, collapse = ", ")

    # Specify which group of nodes to query
    node_group <- ifelse(selected, "selected", "all")

    # Create the request body
    req_body <- jsonlite::toJSON(
        list(
            nodeList = node_group,
            propertyList = properties_str
        ),
        auto_unbox = TRUE
    )

    # Create the filter
    r <- httr::POST(
        url = paste0(
            current_base,
            "/commands",
            "/node",
            "/get%20properties"
        ),
        body = jsonlite::fromJSON(req_body),
        encode = "json",
        handle = NULL
    )

    # Check the status of the response
    if (r$status != 200) {
        stop(sprintf("Failed to create filter: Code %s", r$status))
    }

    # Parse the response
    selected_nodes <- jsonlite::fromJSON(httr::content(r, "text"))

    return(selected_nodes)
}

# Parse the properties of the nodes into a data frame
#
# Args:
#   properties_list: The list of properties
#
# Returns:
#   A data frame with the properties of the nodes
parse_node_properties <- function(properties_list) {
    # Initialize the data frame
    node_properties_df <- data.frame()

    # Iterate over the properties
    for (i in seq_len(nrow(properties_list))) {

        # Get the SUID of the current node
        node_suid <- properties_list[i, ]$SUID

        # Select the properties for the given node
        curr_properties <- properties_list[i, ]$visualProperties
        curr_properties <- curr_properties[[1]]

        # Create a new row for the data frame
        new_row <- t(data.frame(curr_properties))
        rownames(new_row) <- NULL
        colnames(new_row) <- new_row[1, ]
        new_row <- new_row[2, ]

        # Add the SUID to the new row
        new_row$SUID <- node_suid

        # Add the new row to the data frame
        node_properties_df <- rbind(node_properties_df, new_row)
    }

    return(node_properties_df)
}

# Modify the network layout to clean it up
RCy3::layoutNetwork(layout.name="force-directed", base.url=cyrest_url)

# Define the filter JSON
filter_json <- list(
    id = "CompositeFilter",
    parameters = list(
        type = "ALL"
    ),
    transformers = list(
        list(
            id = "TopologyFilter",
            parameters = list(
                predicate = "GREATER_THAN_OR_EQUAL",
                distance = 3,
                threshold = 3,
                type = "ALL"
            ),
            transformers = list()
        )
    )
)

# Create the filter
filter_response <- create_filter(cyrest_url, filter_json, "limitnodes", TRUE)
```

By filtering, we can see which terms pass our filter and are likely deeply connected to other terms in the network. To fetch these terms, we will look up the `Label` property of each term in our filter.

```{r fetch_properties, eval=TRUE, warning=FALSE, message=FALSE}
# Get the SUIDs of the selected nodes
node_suids <- get_node_suids(cyrest_url)
node_suids <- node_suids$data$nodes

# Specify the properties to fetch
properties <- c("Label", "Fill Color", "X Location", "Y Location", "Size")
node_properties <- get_node_properties(cyrest_url, properties, TRUE)

# Parse the properties into a data frame
node_properties_df <- parse_node_properties(node_properties$data)

# Use the colour to determine the regulation
node_properties_df$Regulation <- ifelse(
    node_properties_df$NODE_FILL_COLOR == "#2166AC",
    "Downregulated",
    "Upregulated"
)

# Sort the data frame by the Regulation column
node_properties_df <- node_properties_df[order(node_properties_df$Regulation, decreasing = TRUE), ]
rownames(node_properties_df) <- NULL

# Output the table
knitr::kable(
    node_properties_df[c("SUID", "NODE_LABEL", "Regulation")],
    caption = "Selected nodes in the Enrichment Map."
)
```

## Creating a Theme EM

With some initial exploration on which terms based the thresholding and the filtering, we will complete building the enrichment map by creating a theme EM. This will involve collapsing the network to create a more concise visual representation of the network.

```{r create_theme_enrichment_map, eval=TRUE, warning=FALSE, message=FALSE}
# Function to collapse the current enrichment map using the provided cyrest_url
#
# Args:
#   current_base: The base URL of the Cytoscape REST API
#
# Returns:
#   The response from the Cytoscape REST API
collapse_enrichment_map <- function(current_base) {
    # Annotate the network
    response <- RCy3::commandsGET(
        paste(
            "autoannotate collapse",
            "network=current",
            sep = " "
        ),
        base.url = current_base
    )

    return(response)
}

# Collapse the network
annotated_network <- collapse_enrichment_map(cyrest_url)

# Define the properties to fetch
properties <- c("Label", "Fill Color")
node_properties <- get_node_properties(cyrest_url, properties, FALSE)
collapsed_node_df <- parse_node_properties(node_properties$data)

# Select all non-grey nodes
RCy3::selectNodes(
    collapsed_node_df[collapsed_node_df$NODE_FILL_COLOR != "#F0F0F0", ]$SUID,
    base.url = cyrest_url
)

# Hide the selected nodes
RCy3::hideSelectedNodes(base.url = cyrest_url)

# Only keep the #F0F0F0 nodes
collapsed_node_df <- collapsed_node_df[
    collapsed_node_df$NODE_FILL_COLOR == "#F0F0F0", ]
rownames(collapsed_node_df) <- NULL

RCy3::createDegreeFilter(
    "disconnected",
    c(0, 0),
    base.url = cyrest_url,
    apply = TRUE
)

# Hide the disconnected nodes
RCy3::hideSelectedNodes(base.url = cyrest_url)

# Select the "apc mediated degredation" node
noi <- RCy3::selectNodes(
    collapsed_node_df[collapsed_node_df$NODE_LABEL == "apc mediated degradation", ]$SUID,
    base.url = cyrest_url
)
# Change the fill color of the selected node
RCy3::setNodePropertyBypass(
    node.names = noi$nodes,
    new.values = "#C3E88D",
    visual.property = "Fill Color",
    base.url = cyrest_url
)

# Add annotation to the network
RCy3::addAnnotationBoundedText(
    "Collapsed Nodes",
    200,
    -100,
    24,
    0.0,
    base.url = cyrest_url
)
RCy3::commandsPOST(
    paste("annotation add shape", "type=circle", "x=200", "y=-50", "width=20", "height=20", "fillColor=#F0F0F0", "canvas=background", "view=CURRENT", sep=" "),
    base.url = cyrest_url
)
RCy3::addAnnotationText(
    "A collapsed node.",
    230,
    -50,
    24,
    0.0,
    base.url = cyrest_url
)
RCy3::commandsPOST(
    paste("annotation add shape", "type=circle", "x=200", "y=0", "width=20", "height=20", "fillColor=#C3E88D", "canvas=background", "view=CURRENT", sep=" "),
    base.url = cyrest_url
)
RCy3::addAnnotationText(
    "Term-of-interest",
    230,
    0,
    24,
    0.0,
    base.url = cyrest_url
)
RCy3::fitContent(base.url = cyrest_url)

# Load the image
em_image <- file.path(
    em_output_dir,
    "CBDI_vs_CBDH_annotated_theme_network_pub.svg"
)

# Display the image
knitr::include_graphics(em_image)

# Display the table of the collapsed nodes
knitr::kable(
    collapsed_node_df[c("SUID", "NODE_LABEL")],
    caption = "Collapsed nodes in the Enrichment Map."
)
```

## Insights

**1. Create an enrichment map.**

I created two enrichment maps with different thresholds because I wanted to see the effects that tuning thresholds would have, in comparison to the default values.

```{r show_initial_map, echo=FALSE, warning=FALSE, error=FALSE, out.width = "100%", fig.show='hold', fig.cap="Initial Enrichment Map of GSEA Results Comparing SARS-CoV-2-infected and Healthy ACE549 cells treated with CBD (p = 1.0, q = 0.05, similarity = 0.375)"}
knitr::include_graphics(c("output/em_results/CBD_vs_DMSO_initial_network.png"))
```

```{r show_stringent_map, echo=FALSE, warning=FALSE, error=FALSE, out.width = "100%", fig.show='hold', fig.cap="Stringent Enrichment Map of GSEA Results Comparing SARS-CoV-2-infected and Healthy ACE549 cells treated with CBD (p = 1.0, q = 0.01, similarity = 0.375)"}
knitr::include_graphics(c("output/em_results/CBD_vs_DMSO_stringent_network.svg"))
```

**2. How many nodes and how many edges are in your enrichment map?**

The *initial network* has `r num_nodes_initial` nodes and `r num_edges_initial` edges. On the other hand, the *stringent network* has `r num_nodes_stringent` nodes and `r num_edges_stringent` edges.

**3. What thresholds did you use to create your enrichment map?**

To create the enrichment map, I used the following thresholds:

| Network Version | P-Value Threshold | Q-Value Threshold | Similarity Threshold |
|-----------------|-------------------|-------------------|----------------------|
| Initial         | 1.0               | 0.05              | 0.375                |
| Stringent       | 1.0               | 0.01              | 0.375                |

**4. What parameters did you use to annotate the network?**

For annotation, I used [AutoAnnotate](https://autoannotate.readthedocs.io/en/latest/index.html) because of how simple it is to use and integrate into the Cytoscape workflow [@Kucera2016]. For the annotations, I ran both the `autoannotate annotate-clusterBoosted` and `autoannotate annotate-sizeSorted` commands to compare the output, but decided to proceed with just `autoannotate annotate-clusterBoosted`.

For the `autoannotate annotate-clusterBoosted` command, I used the default parameters:

- `adjacentWordBonus`: 8
- `clusterAlgorithm`: MCL
- `maxWords`: 3
- `minWordOccurrence`: 1

My annotated figures are below.

```{r show_annotated_map, echo=FALSE, warning=FALSE, error=FALSE, out.width = "100%", fig.show='hold', fig.cap="Initial Annotated Enrichment Map of GSEA Results Comparing SARS-CoV-2-infected and Healthy ACE549 cells treated with CBD (p = 1.0, q = 0.05)"}
knitr::include_graphics(c("output/em_results/CBD_vs_DMSO_annotated_network.png"))
```

```{r show_annotated_theme_map, echo=FALSE, warning=FALSE, error=FALSE, out.width = "100%", fig.show='hold', fig.cap="More Stringently Annotated Enrichment Map of GSEA Results Comparing SARS-CoV-2-infected and Healthy ACE549 cells treated with CBD (p = 1.0, q = 0.01)"}
knitr::include_graphics(c("output/em_results/CBD_vs_DMSO_annotated_theme_network.svg"))
```

**5. Create a publication ready figure.**

An issue with the figures above is that there is no clear theme due to the size of the network and all the distinct groupings. To address this, we can focus on a subset of the network that focuses on one of the major themes. With a more focused network, we can also consider additions like a legend which would be necessary for something that's publication-level. The figure below is in `.svg` format to allow for easy editing and scaling, which is often used for publication-quality networks.

```{r show_theme_map, echo=FALSE, warning=FALSE, error=FALSE, out.width = "100%", fig.show='hold', fig.cap="Annotated Theme Network of GSEA Results Comparing SARS-CoV-2-infected and Healthy ACE549 cells treated with CBD (p = 1.0, q = 0.01)"}
knitr::include_graphics(c("output/em_results/CBDI_vs_CBDH_annotated_theme_network_pub.svg"))
```

Note tha this figure was generated via automating Cytoscape through CyREST. Unfortunately, the *apc mediated degredation* node is not highlighted in this figure as the automation would not change the `Fill Color` property of the node, but be aware that this node is the "theme of interest".

**6. Collapse your network to create a theme network.**

See Above.

**7. What are the major themes present in this analysis? Do they fit with the model?**

```{r show_themes, eval=TRUE, warning=FALSE, message=FALSE}
knitr::kable(
    collapsed_node_df[c("SUID", "NODE_LABEL")],
    caption = "Collapsed nodes in the Enrichment Map."
)
```

**8. Are there any novel pathways or themes in this analysis?**

*TODO*

## Interpretation

**1. Do the enrichment results support conclusions or mechanism discussed in the original paper?**

One of the key findings of this analysis and inspecting the final EM is that the **apc mediated degredation** pathway forms the largest cluster of related terms. The original publication does *not* outwardly discuss this pathway or the role of antigen-presenting cells (APCs), however, it is generally known that APCs play a crucial role in the immune response to infection- be it pathogenic or tumor-related [@Rastogi2022].

This outcome *does* support what was initially discussed in the publication

**2. Can you find other studies to support some of the results that you see? How does this evidence support your result?**

One article discusses the mechanisms of the mRNA vaccines from different pharma companies during the COVID-19 pandemic, and it explains how the vaccine acts in relation to other phenomena. A key portion that connects to the idea of *apc mediated degredation* is their mention of how t

*TODO*

# References
::: {#refs}
:::